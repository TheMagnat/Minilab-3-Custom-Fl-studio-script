"""
[[
	Surface:	MiniLab3
	Developer:	Farès MEZDOUR
	Version:	1.0.1

    Copyright (c) 2022 Farès MEZDOUR
]]
"""

import device
import ui
import time
import transport
import mixer
import channels
from MiniLab3Dispatch import send_to_device 



# This class handles visual feedback functions.


WidMixer = 0
WidChannelRack = 1
WidPlaylist = 2
WidBrowser = 4
WidPlugin = 5


# MAPS

PAD_MAP = [
        0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B]

        
COLOR_MAP = [
        [0x00, 0x7F, 0x10],
        [0x00, 0x7F, 0x19],
        [0x00, 0x7F, 0x32],
        [0x00, 0x7F, 0x4B],
        [0x00, 0x7F, 0x64],
        [0x00, 0x7F, 0x7F],
        [0x00, 0x64, 0x7F],
        [0x00, 0x4B, 0x7F],
        [0x00, 0x32, 0x7F],
        [0x00, 0x19, 0x7F],
        [0x00, 0x00, 0x7F],
        [0x19, 0x00, 0x7F],
        [0x32, 0x00, 0x7F],
        [0x4B, 0x00, 0x7F],
        [0x64, 0x00, 0x7F],
        [0x7F, 0x00, 0x7F],
        [0x7F, 0x00, 0x64],
        [0x7F, 0x00, 0x4B],
        [0x7F, 0x00, 0x32],
        [0x7F, 0x00, 0x19],
        [0x7F, 0x00, 0x00],
        [0x7F, 0x19, 0x00],
        [0x7F, 0x32, 0x00],
        [0x7F, 0x4B, 0x00],
]

ON_START_ON_INPUT_COLOR = [0x7F, 0x32, 0x00]
ON_START_ON_INPUT_OFF_COLOR = [0x14, 0x05, 0x00]

ON_STEP_COLOR = [0x7F, 0x32, 0x00]
ON_STEP_OFF_COLOR = [0x14, 0x05, 0x00]

ON_LOOP_COLOR = [0x7F, 0x32, 0x00]
ON_LOOP_OFF_COLOR = [0x14, 0x05, 0x00]

ON_PLAY_COLOR = [0x00, 0x7F, 0x00]
ON_PLAY_OFF_COLOR = [0x00, 0x14, 0x00]

ON_RECORD_COLOR = [0x7F, 0x00, 0x00]
ON_RECORD_OFF_COLOR = [0x14, 0x00, 0x00]

ON_STOP_COLOR = [0x14, 0x14, 0x14]

class MiniLabLightReturn:

    def init(self):
        self.isWaitingForInput = False

        send_to_device(bytes([0x04, 0x02, 0x16, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00]))
        time.sleep(0.2)
        send_to_device(bytes([0x04, 0x02, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))
        time.sleep(0.2)
        send_to_device(bytes([0x04, 0x02, 0x16, 0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14]))

        self.updateAll(False, False)

    def updateAll(self, isShift, isSnapToScale):
        self.updateSnapToScale(isShift, isSnapToScale)

        self.LoopReturn(isShift)
        self.PlayReturn(isShift)
        self.RecordReturn(isShift)
        self.StepReturn(isShift)
        self.WaitForInputReturn(isShift)

    def MetronomeReturn(self) :
        if ui.isMetronomeEnabled() :
            send_to_device(bytes([0x02, 0x02, 0x16, 0x54, 0x7F, 0x7F, 0x00]))
        else :
            send_to_device(bytes([0x02, 0x02, 0x16, 0x54, 0x14, 0x14, 0x00]))
    
    def updateUndoRedo(self, isPressed):
        if isPressed:
            send_to_device(bytes([0x02, 0x02, 0x16, 0x0B, 0x7F, 0x7F, 0x7F]))
        else:
            send_to_device(bytes([0x02, 0x02, 0x16, 0x0B, 0x14, 0x14, 0x14]))

    def updateSnapToScale(self, isShift, isActivated):
        if not isShift:
            if isActivated:
                send_to_device(bytes([0x02, 0x02, 0x16, 0x04, 0x7F, 0x7F, 0x7F]))
            else:
                send_to_device(bytes([0x02, 0x02, 0x16, 0x04, 0x14, 0x14, 0x14]))

    def updateStop(self, isPressed):
        if isPressed:
            self.isWaitingForInput = False
            send_to_device(bytes([0x02, 0x02, 0x16, 0x08, 0x7F, 0x7F, 0x7F]))
        else:
            send_to_device(bytes([0x02, 0x02, 0x16, 0x08, 0x14, 0x14, 0x14]))

    def WaitForInputReturn(self, isShift):
        if not isShift:
            if ui.isStartOnInputEnabled():
                send_to_device(bytes([0x02, 0x02, 0x16, 0x05, *ON_START_ON_INPUT_COLOR]))
            else :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x05, *ON_START_ON_INPUT_OFF_COLOR]))

    def StepReturn(self, isShift):
        if not isShift:
            if ui.getStepEditMode():
                send_to_device(bytes([0x02, 0x02, 0x16, 0x06, *ON_STEP_COLOR]))
            else :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x06, *ON_STEP_OFF_COLOR]))

    def LoopReturn(self, isShift):
        if not isShift:
            if ui.isLoopRecEnabled() :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x07, *ON_LOOP_COLOR]))
            else :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x07, *ON_LOOP_OFF_COLOR]))

    def PlayReturn(self, isShift):
        if not isShift:
            if self.isWaitingForInput or mixer.getSongTickPos() != 0 :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x09, *ON_PLAY_COLOR]))
            else :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x09, *ON_PLAY_OFF_COLOR]))
            
    def RecordReturn(self, isShift) :
        if not isShift:
            if transport.isRecording() :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x0A, *ON_RECORD_COLOR]))
            else :
                send_to_device(bytes([0x02, 0x02, 0x16, 0x0A, *ON_RECORD_OFF_COLOR]))

    def ProcessPlayBlink(self, value, isShift):
        self.isWaitingForInput = False
        if not isShift:
            COLOR_PLAY_ON = bytes([0x02, 0x02, 0x16, 0x09, *ON_PLAY_COLOR]) 
            COLOR_PLAY_OFF =  bytes([0x02, 0x02, 0x16, 0x09, *ON_PLAY_OFF_COLOR]) 
            if value == 0 :
                send_to_device(COLOR_PLAY_OFF)
            else :
                send_to_device(COLOR_PLAY_ON)
        
    def ProcessRecordBlink(self, value, isShift) :
        if not isShift:
            if transport.isRecording() :            
                COLOR_RECORDING_ON = bytes([0x02, 0x02, 0x16, 0x0A, *ON_RECORD_COLOR]) 
                COLOR_RECORDING_OFF = bytes([0x02, 0x02, 0x16, 0x0A, *ON_RECORD_OFF_COLOR]) 
                if value == 0 :
                    send_to_device(COLOR_RECORDING_OFF)
                else :
                    send_to_device(COLOR_RECORDING_ON)
                
    def LEDTest(self) :
        send_to_device(bytes([0x02, 0x02, 0x16, 0x04, 0x00, 0x00, 0x7f]))
        send_to_device(bytes([0x02, 0x02, 0x16, 0x05, 0x00, 0x00, 0x00]))
        time.sleep(1.0)
        send_to_device(bytes([0x02, 0x02, 0x16, 0x04, 0x00, 0x00, 0x00]))
        send_to_device(bytes([0x02, 0x02, 0x16, 0x05, 0x00, 0x00, 0x7f]))
        time.sleep(1.0)

    
        
    

         
           

 
